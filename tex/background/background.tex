\documentclass[class=article, crop=false]{standalone}

%\addbibresource{refs.bib}

\begin{document}
	Before we begin to delve into the development of our project, it is important we first discuss the prior state of the problem. In particular, we introduce the reader to some key ideas that helped to compose the final presented solution. This shall also give us a chance to elaborate on the aims of the project.

	\section{The Game of Tron}
		The game of Tron first emerged in response to a scene from the 1982 film bearing the same name, Tron \parencite{TronLightCycleBattle}. These games often took their own spin on the concept, adjusting certain game mechanics. Hence, to help avoid ambiguity, we first describe, in detail, the rules of the game. These are the rules adhered to throughout the project's development.

		Tron is a free-for-all game played by two or more players. Players are spawned, in a uniform distribution, around the four sides of a square, enclosing the game's arena. Each player is themselves a smaller square, 1 unit in size, that is initially \emph{directed} facing inwards of the square. Once the game has commenced, all \emph{alive} players are perpetually in motion, travelling around the arena at the same constant speed. However, at any time, the player can direct themselves 90\si{\degree} anti-clockwise (left) or 90\si{\degree} clockwise (right). As each player travels around the game arena, they leave a \emph{wall} occupying the arena they previously covered. This continuous wall is know as a \emph{trail}, and can be though of as the travelled path of a particular player. A player is considered to be \emph{dead}, and out the current game, when they collide with borders of the arena, any other player, or the trail of any player (including their own). Hence, the goal of the game is for a player to travel around the game arena long enough to outlive all other competing players. This also introduces strategic play, as, for example, players are able to act aggressively in hopes to block off their opponents - defeating them sooner. A round of the game is considered finished once only a single player remains \emph{alive}. In this case, the single remaining player is considered the \emph{winner}. If no players are left \emph{alive}, the game is considered to be a draw.

	\section{Existing Games} \label{sec:existingGames}
		As it stands, there are quite a few implementations of Tron in existence. Some are relatively small \enquote{indie} titles, whilst others are in the form of an extraneous minigame within a AAA title. We shall begin to discuss some of these existing implementations, providing a brief overview of the functionality they offer and their incorporated techniques. It is worth noting, we focus primarily on the smaller titles as they better relate to the scope of our project.

		First up is Fltron \parencite{Fltron}. Fltron is an Adobe Flash based, two-player, grid-base implementation of Tron. It features a fairly skillful AI opponent, sufficiently capable of mimicking human behaviour. The game is also complete with a fair amount of polish, such as sound effects and aesthetic graphics. However, it does not support multiplayer over a network. It also happens to be quite outdated, incompatible with many modern browsers, due to its reliance on Adobe Flash which slowly being phased out in favour of HTML5. \parencite{Html5Flash} 

		Cycleblob \parencite{Cycleblob} is yet another Tron implementation. Although, it is unique in the regards that the game arena is a three-dimensional object; configurable to a variety of interesting shapes, such as a rounded cube or torus. It is quite a modern development, utilising many of the exciting HTML5 technologies, such as \emph{WebGL} \parencite{WebGl}. Similar to the aforementioned Fltron, the game features a capable AI opponent but still lacks multiplayer functionality.

		Slither IO \parencite{SlitherIo} is an extremely popular browser-based game. Whilst it is not an implementation of Tron, it is very similar in concept. What makes this game particularly interesting, is that it demonstrates a high-level of technical capability. The game is multiplayer, enabling hundreds of players to compete against one-another in a single game instance. This clearly advocates some of what is possible within a modern web-browser. However, it is worth noting that the game is entirely player vs player; there are aspects of artificial intelligence.

		Rounding off on what has been discussed, it is evident that these technologies, powering the modern web-browser, do hold a lot of promise. There is strong indication that they are indeed capable candidate platforms for running robust video-games of the arcade genre. However, there does not yet seem to exist a modern browser-based multiplayer implementation of Tron.

	\section{Browser Technologies} \label{sec:browserTechnologies}
		A modern web-browser is now equipped with a wide array of different technologies, many of which accomplish very similar goals. When it comes to settling on a particular technology, there is no \enquote{one-size-fits-all} solution. Each are viable options under under certain circumstances. It is because of this, in the following section, we compare some of these competing technologies to enable us to better justify our future design decisions.

		Firstly, we shall discuss some of the technologies whose purpose it will be to render the game's graphics. Some of the possible contenders include: animating DOM elements around using JS, or even CSS; SVG; a canvas element powered by Canvas 2D; a canvas element powered by WebGL. However, from those options, there are only two feasible candidates: WebGL and Canvas 2. WebGL is a low-level graphics API, and is based upon OpenGL ES. It provides the developer with a high amount of control over the graphics pipeline and is also capable of 3D graphics. On the other hand, canvas 2D is (as the name suggests) intended for relatively simple 2D graphics, and abstracts quite significantly away from the graphics pipeline - trading off control for ease-of-use.

		For the task of network communication, there are many choices. However, the two main relevant technologies, for modern browsers, are WebSockets and WebRTC. There are a few key differences between the two. Firstly, WebSockets utilises the Transmission Control Protocol (TCP) protocol whilst, on the other hand, WebRTC can utilise either TCP or the User Datagram Protocol (UDP). Another key difference is that WebSockets only supports full-duplex communication between a web-browser and a web-server, whilst WebRTC's extends upon this by supporting full-duplex communication between two web-browsers. WebRTC requires that a web-server be set-up to handle the initial signalling required to establish a connection between two browsers. As one would expect, WebRTC is slightly more complicated to use, it also happens to be a newer standard and is not currently very well support amongst web-browsers.

	\section{Artificial Intelligence} \label{sec:background-google-ai}
		As discussed previously (see \fullref{sec:existingGames}), there are already several Tron implementations out there in existence. Some of these already feature an adequately sophisticated computer opponent that is controlled by an artificial intelligence. Sadly, some of these implementations do not have publicly accessible source-code, or developer documentation; making it very difficult to understand the techniques they're using. However, after further research it was discovered that conveniently, in 2010, Google sponsored an AI challenge \parencite{GoogleTronAi}, which received over 1400 entries. This objective of this challeneg was to devise a artificial intelligence capable of playing the game Tron; albeit, with a slightly different set of rules and in slightly different circumstances. The winner of said competition, \emph{a1k0n}, released a descriptive post-mortem \parencite{TronPostMortem}, complete with source-code, detailing the core ideas behind what powered their submission. However, the produced artificial intelligence would be able to outmatch the majority of human controller players.
\end{document}