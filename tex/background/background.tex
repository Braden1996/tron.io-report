\documentclass[class=article, crop=false]{standalone}

%\addbibresource{refs.bib}

\begin{document}
	Before delving further, it is important we introduce some of the ideas that helped to form the presented solution. We shall discuss these throughout this chapter.

	\section{The Game of Tron}
		The game of Tron first emerged in response to a scene from the 1982 film bearing the same name, Tron \parencite{TronLightCycleBattle}. To help avoid ambiguity we shall first describe, in detail, the rules of the game; as they have been understood for this project.

		Tron is a free-for-all game which can be played by two or more players. Players are spawned as a square and are uniformly distributed along the four sides of a square which encloses the game's arena. Initially, each player is \emph{directed} inward towards the square.

		All alive players are perpetually in motion, travelling around the arena at the same constant speed. However, at any time, they're able to direct themselves either 90\si{\degree} left or 90\si{\degree} right.

		As a player travels, they leave a wall which occupies the entire area that they have covered. We call this a \emph{trail}, and can be thought of as the travelled path of a particular player.

		A player is considered \emph{dead} if they collide with any of the following: the borders of the arena; any other player; or, the trail of any other player (including themselves).

		The game is considered to be finished when there are less than two players alive. In the case where a single player is left alive, they are considered to be the \emph{winner}. Otherwise, the game is a \emph{draw}.

	\section{Existing Games}
		There are quite a few implementations of Tron out there; scaling from small/indie projects to a minigame within a AAA titles. We shall now discuss some of these implementations and provide a brief overview of what they offer.

		First up is Fltron \parencite{Fltron}. Fltron is a flash-based, two-player, grid-base implementation of Tron which features a fairly skilful AI opponent. Although the game comes with quite a high amount of polish, it does not support multiplayer over a network. Also, Flash is slowly being phased out of use in favour of the new capabilities brought to the modern web with HTML5. \parencite{Html5Flash} 

		Cycleblob \parencite{Cycleblob} is a more recent alternative which has migrated to the newer HTML5 technologies. It utilises \emph{WebGL} \parencite{WebGl}. What makes Cycleblob especially unique is that the game is played in three-dimensions on a variety of unusual shapes; such as a rounded cube and a torus. Similar to Fltron, it features a challenging AI opponent but lacks multiplayer capabilities.

		Slither IO \parencite{SlitherIo} is an extremely popular browser-based game which, although is not a Tron game, is very similar in concept. Its most attractive quality is being that hundreds of players are able to simultaneously play together within the same instance. I believe this demonstrates the extent at which HTML5's networking capabilities can extend to. It is worth noting that Slither IO has no AI opponents - it is entirely player vs player.

		To conclude, it seems that many of the new HTML5 technologies are indeed more than capable candidates in powering robust arcade games; eliminating the need for alternatives such as Flash. However, there doesn't seem to yet be a modern browser-base implementation of Tron.

	\section{Browser Technologies}
		Web browsers now come packed with a wide array of different technologies, many of which accomplish very similar goals. This is demonstrated by the various technology stacks in which the currently existing browser games are built upon. In the following section we shall compare some of these competing technologies in attempt to justify our future design decisions.

		Many technologies built into the browser are capable of rendering some form of graphics for a video-game. Some of the possible contenders include: animating DOM elements around using JS, or even CSS; SVG; a canvas element powered by Canvas 2D; a canvas element powered by WebGL.

		However, as we have no real concern for massively outdated browsers, there exist two primary contenders for video-game graphics; WebGL and Canvas. WebGL is a low-level graphics API, and is based upon OpenGL ES. It provides the developer with a high amount of control over the graphics pipeline and is also capable of 3D graphics. On the other hand, canvas 2D is (as the name suggests) intended more for relatively simple 2D graphics, and abstracts quite significantly away from the graphics pipeline - trading off control for ease-of-use.

		For the task of network communication, there are many choices. However, the two main relevant technologies for modern browsers are WebSockets and WebRTC. The key differences between the two are that WebSockets works via TCP whilst WebRTC works via both TCP and UDP, and that WebSockets only supports full-duplex communication between a browser and a web server, whilst WebRTC's supports full-duplex communication between two browsers. 

		However, WebRTC requires signalling to take place in order to establish the connection. This is usually done using WebSockets. WebRTC is also a far newer standard and isn't that well supported across web-browsers.

	\section{Artificial Intelligence}
		As talked about above, there are already several Tron implementation in existence which feature a sufficiently sophisticated computer opponent that is controlled by an artificial intelligence. Sadly, these implementations aren't accompanied by any source-code or documentation; making it very difficult to understand the techniques they're using.

		However, after further research it was discovered that conveniently in 2010 Google sponsored an AI challenge\parencite{GoogleTronAi}, which received over 1400 entries, involving the creation of an AI capable of playing Tron; albeit in slightly different circumstances. Also, \emph{a1k0n}, the winner of the Competition, released a post-mortem\parencite{TronPostMortem} complete with source-code detailing their submission. \label{sec:background-google-ai}
\end{document}