\documentclass{standalone}

\begin{document}
	The project has now come to an end, giving us the chance to round off and conclude our findings. This chapter will provide the reader with a summary, and brief elaboration, on what has been accomplished, including both the successes and failures. We shall begin with a general overview of the project, before delving into some of the more specific aspects.

	To begin with, the most prevalent blunder was deciding to base the game on free movement, as opposed to cell-based movement. This proved to be quite an inconvenience, complicating a range of tasks, without offering all that much benefit to the user experience; due to the visual difference being near indistinguishable. However, many of these inconveniences were overcome and the project now demonstrates a higher level of capability.

	\section{Networking}
		Since the conception of the project, the game has been designed according to the client/server network architecture model (see \fullref{sec:architectureOverview}). This has suited the project quite nicely, especially with the additional techniques used to reduce latency (see \fullref{sec:networkCommunication}). Players are able to interact with each-other in real-time, with minimal perceptible latency. This is primarily due to lag-compensation and client-side prediction. However, occasionally client-side prediction will result in \emph{flashes}, indicating an inconsistency between the client's predicted state and that communicated by the authoritative server. In particular, this occurs for a client when another player redirects themselves moments before collision - causing their trail to flash red, as their death was incorrectly predicted. This could either be manipulated to be a feature (possibly change to orange during prediction, then red once death is confirmed by the server) or make the client prediction only predict player movement, not collisions.

		A large amount of time was also invested in enabling the game to support an arbitrary number of game lobbies. The functionality does exist and works as one would expect. However, it simply does not scale very well. Despite many efforts, such as those related to concurrency (see \fullref{sec:lobbyConcurrency}), a single dedicated game server is only capable of feasibly running just a few game instances, and is dramatically hindered by high-numbers of computer players - due to their artificial intelligence. Quite early on during development, this issue started to get recognised as a potential problem that may later arise. In fact, significant efforts were made to prepare for an adjustment regarding the network architecture. In particular, it was conceptualised that the dedicated server would pick the most-capable connected player in a lobby to play the role of the game server, perhaps cycling through the players as an anti-cheat measure. This alternative strategy would dramatically reduce load on our dedicated server, as it would then only be responsible for establishing the connection between players in the same lobby. To reduce the amount of work required in transitioning to the aforementioned strategy, specialised software-development techniques, such as dependency injection, have been utilised throughout the game's networking functionality, to ensure minimal coupling to Node.js.

		Despite this, a complete transition was not viable due to numerous setbacks. The main setback faced, was that regarding the fact Web-Sockets is not capable of browser-to-browser communication. This leaves open two potential solutions: proxy messages through the dedicated server, or, more favourably, convert the communication medium to WebRTC. However, time did not permit the ability to undertake either solutions, without impeding other aspects of the project.

	\section{Artificial Intelligence}
		The game features a computer controller player that determines their move based upon some artificial intelligence techniques. These techniques centre around the idea of running simulations, exploring the various scenarios derived from the current game state.

		Artificial intelligence based upon simulation is scarcely utilised when performance is of a critical concern. This is primarily due to the large computational expense involved with running simulations, as they are of a \enquote{trial-and-error} nature. Alternatively, a more ideal solution would analyse only the current game state to determine a move. Despite this, many of existing Tron AI solutions saw great success from utilising game tree simulations; indicating that it was indeed a viable direction. In practice, our implemented artificial intelligence performs quite well, and can even be considered a strong contender against human users. Regardless of this, the goal was to create an AI which mimicked human strategy and behaviour; as opposed to being of an incredibly high skill-level. Hence, it is in this regard we must state that the implemented artificial intelligence does not perform entirely as desired. In particular, it would occasionally play bizarre moves in which the strong move is easily identifiable by even a novice human player. Conflictingly, the artificial intelligence also suffered issues regarding the timing of moves. However, this is not strictly a bad thing as it also happens to be a trait of human users.

		In conclusion, the artificial intelligence that has been implemented does suit our particular use-case quite well, that is the realistic playing of Tron. But questions are raised regarding a simulation based AI being suitable for more complex video-games, where performance and accuracy are of a critical concern.
\end{document}	