\documentclass{standalone}

\begin{document}
	There were many decisions, and mistakes that influenced them, made throughout the design of the application. As all mention of these were omitted from the design chapter \fullref{chap:design} in order for it to remain concise, so we shall instead discuss them here.

	\section{Project Structure}
		\subsection{Dependencies}

	\section{Game Mechanics}
		\subsection{Game Loop}
			Constructing the game loop is a seemingly simple task; a timer which would tick at a rate equal to our desired tick-rate. However, in fact, many issues were encountered.

			On the client, we are able to use JavaScript's \emph{window.requestAnimationFrame()} \parencite{JsRequestAnimationFrame} which is ideal for a loop intended for creating animation through drawn graphics. However, this function is not available on our Server's Node environment; so we'll have to find a separate solution.

			JavaScript's standard built-in timer, \emph{setTimeout()} \parencite{JsSetTimeout}, does not work with a sufficiently reliable accuracy - frequently off by several milliseconds. And its alternative, \emph{setImmediate()} \parencite{JsSetImmediate}, calls at such an incredibly high-frequency that it consumes too many resources.

			Thankfully, it turns out that this problem has been tackled by others. One proposed solution \parencite{JsGameLoop} was to use \emph{setTimeout()} then switch to \emph{setImmediate()} when we enter the window of potential error.

		\subsection{Head-on Player Collisions}
			Within the game loop, we first move all the players and then check each player to see if it has crashed. Once all players have been checked, we process these newly dead players by switching their alive flag to false and repositioning them to their previous position at the moment of impact.

			In the case where two players die in a head-on collision, both players would be repositioned in such a way that they are not visibly touching - appearing to be an invalid death. To combat this issue, for the said case, a separate solution had to be created. This solution is described in \fullref{itm:headCollision}.

		\subsection{Game State}
			\subsubsection{Collision Data Structures}
				Currently, a uniform grid is used to store the objects within our arena, although originally a quad-tree was instead implemented and used. This worked, but for the case of Tron, a hierarchical structure doesn't hold all that much benefit over a much simpler uniform grid.

				It also happens that a uniform grid is far easier to implement, simpler to test and works well in an environment where many objects remain static.

			\subsubsection{Mutability}
				Initially, the game's state was developed to be an immutable object; where all functions made no changes to the given game state, but instead returned an entirely new object with the desired changes applied. This helps to reduce obscure bugs and makes the code far easier to test - especially for unit tests.

				However, it also required performing a deep copy of the game state prior to any single change to be made. This is an extremely costly operation to be performing within a game loop, specially when it would have to be performed several times per tick. Realising this wasn't viable, the application was modified to internally use a mutable game state and to manually copy it where need be (e.g. for lag compensation, see \fullref{sec:lagCompensation}).

				Irritatingly, this caused some difficult to trace bugs. One of the most notable of these was related to copying the game state and collision data-structure within our game state's cache. In short, each object within the collision data-structure keeps a reference to the player which created it. When we then copied the game state, the stored objects did not have their player references updated to match those of the newly created player objects themselves. This resulted in a broke collision detection, related to the workings of our lag compensation.

	\section{Artificial Intelligence}
		minimax -> monte-carlo
\end{document}