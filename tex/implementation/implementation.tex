\documentclass{standalone}

\begin{document}
	Both the design and implementation processes occurred simultaneously, that is the implementation of our application evolved alongside the development of its final design. During the design chapter \fullref{chap:design}, we only discussed the final state of the system - to avoid creating confusion on what was actually created. However, throughout this chapter, we shall discuss some of the difficulties which were faced, as well as the mistakes that were made and the solutions which we arrived at.

	\section{Game Loop}
		Constructing the game loop is a seemingly simple task. In essence, it is a callback that some timer would make a call to at some fixed interval equal to our tick-rate. However, there were a number of quirks related to JavaScript's standard API which made this task not as straightforward as initially expected.

		On the client, we are able to use JavaScript's \emph{window.requestAnimationFrame()} \parencite{JsRequestAnimationFrame} function. This is called whenever the canvas is preparing to draw the next frame, giving us the opportunity to update the game state - basically hijacking the internal loop used within the browser. This technique worked during the early stages of development, but when we sought to run the game on the browser; it soon became apparent that obviously this function wouldn't exist in a Node.js environment. So, a separate solution needed to be realised.

		Research turned in the direction of JavaScript's standard built-in timer, \emph{setTimeout()} \parencite{JsSetTimeout}. However, after some short tests, said timer was concluded to be improper for the task as it did not tick with sufficiently reliable accuracy - often too late by many milliseconds. However, there existed an alternative function, \emph{setImmediate()} \parencite{JsSetImmediate}. 

		Sadly, this function occupied a high amount of system resources due to it ticking at an incredibly high, and uncontrollable frequency. This resulted with us having to internally disregard calls if a tick was not scheduled.

		Thankfully, after extensive research online, it was discovered that this problem has been tackled by others. A proposed solution\parencite{JsGameLoop} was suggested that recommended to use \emph{setTimeout()} as the primary timer function then, when we enter the window of potential error, switch to \emph{setImmediate()} which provided us with a far greater accuracy. This seemed to work very well!

	\section{Head-on Player Collisions}
		Within the game loop, during the update process of single tick, we first move each and every alive player. Afterwards, we perform a series of checks to identify which players have crashed. Once all players have been checked, we process said newly crashed players by officially \emph{killing} them - which mercifully only entails switching their alive flag to \texttt{false} and reposition them to their theoretical position at the exact moment of impact.

		However, once we began testing, a bug was discovered that players would be repositioned to seemingly incorrect locations after a collision. After further investigation, it was clear that this unexpected behaviour only occurred in the case where two players would collide in a head-on collision, that is they were travelling in opposing directions and met one-another.

		After further thinking with regards to the problem, a solution was devised that modified the way in which players were repositioned. Instead, we would backtrack a player by an amount calculated by half the sum of the overshoot and overlap of the two colliding players. However, this was only necessary for the case in which a head-on collision had occurred. For more information, please see \fullref{itm:headCollision}

	\section{Mutability}
		Initially, the game's state was developed to be an immutable object; where all functions made no changes to the given game state, but instead returned an entirely new object with the desired changes applied. This helps to reduce obscure bugs and makes the code far easier to test - especially for unit tests.

		However, it also required performing a deep copy of the game state prior to any single change to be made. This is an extremely costly operation to be performing within a game loop, specially when it would have to be performed several times per tick. Realising this wasn't viable, the application was modified to internally use a mutable game state and to manually copy it where need be (e.g. for lag compensation, see \fullref{sec:lagCompensation}).

		Irritatingly, this caused some difficult to trace bugs. One of the most notable of these was related to copying the game state and collision data-structure within our game state's cache. In short, each object within the collision data-structure keeps a reference to the player which created it. When we then copied the game state, the stored objects did not have their player references updated to match those of the newly created player objects themselves. This resulted in a broke collision detection, related to the workings of our lag compensation.

	\section{Collision Data Structures}
		In the early stages of the game's development, we would check every object within the arena when searching for collisions. Although this method worked well, and didn't result in any noticeable lag, further research into game development revealed how commonplace spatial data-structures were. This highlighted that our current collision detection mechanic was an urgent area for plausible improvement.

		Progress on the game soon advanced and the use of the hierarchical structure of a quad-tree was implemented and integrated into our game's collision detection, to help reduce the total search space when checking for collisions. This did show some considerable performance gain. However, after playing the game, it became apparent that it was trail line-segments were almost always intercepting multiple nodes - making the need for a hierarchical data-structure somewhat meaningless.

		Hence, a uniform grid was instead implemented and integrated to help optimised our game's collision detection. A uniform grid also has the perk of being far easier to deal-with and works well for the case of Tron.

		Also, to aid in both the creation and debugging of these two spatial data-structures, the game features a special \emph{debug} mode which would visualise the bounds for each node onto the game arena in the form of a semi-transparent overlay.

	\section{AI Simulations}
		As per our design, the game's computer players were powered by an artificial intelligence that ran simulations using a variant of the minimax algorithm \parencite{minimax} that featured alpha-beta pruning \parencite{alphaBeta} to avoid looking down unnecessary branches of the game tree; improving performance.

		However, it was taking far too much time in order for the AI to calculate a suitable move. By the time the AI had calculated a move, the game state would've significantly progress; making their move now redundant - often leading to their undesired death.

		There existed two clear ways in which this performance issue could be tackled. We could either restrict the breadth of our game-tree search, or restrict the depth. Restricting the depth of our AI's game-tree search exponentially reduced its ability to make educated moves - it performed extremely poorly. On the other hand, restricting the breadth of our game-tree search was highly dependent on the situation the AI player is current in; as many of the possible early moves are never simulated.

		This inspired the idea to migrate to using the Monte Carlo Tree Search algorithm, as discussed in \fullref{sec:design-ai}. This allowed our AI to only explore branches of the game-tree that seemed promising; ignoring those branches that almost always led to poor outcomes.

	\section{AI Concurrency}
		In the early iterations of the game's artificial intelligence, the move for a computer controller player would prepare to calculate their next move of a tick; limiting the duration of the entire simulation process to at the most \textless 16 milliseconds. However, it soon became very apparent that this was an inadequate amount of time.

		This provoked research into the possibility of running our artificial intelligence in a concurrently with the rest of the game, allowing simulation to take any pre-defined amount of time. Irritatingly, as developing the artificial intelligence was the final stage of the game's development, I then discovered that Node.js is strictly a single-threaded environment. This was an absolutely devastating discovery...

		Thankfully, after an extortionate amount of research, Node's \texttt{child\_process} module \parencite{nodeChildProcess} was discovered and successfully integrated into our game sever - after much hassle regarding getting it to build correct with our React Universally workflow.

		In short, this Node module allows us to create a fork of an entirely new, and separate Node process which can communicate with our main process. Not only did this allow us to execute our artificial intelligence's simulations without blocking our game loop, but it also reduced the time in which we kept our Node event-loop occupied. It is critical for our Node event-loop to not be used for computationally demanding tasks, as they prevent our server from processing time-sensitive requests such as processing actual user-input or even serving up the application's static files.

		Despite this, it still seemed as though our artificial intelligence was preventing out event-loop from spinning fast enough. After extensive debugging, it was determined that the cause for this delay was due to the fact lag compensation was being applied after we had received the suggested move from our artificial intelligence. This greatly hindered the game's experience, as it made game-play sluggish and inaccurate; obviously this type of behaviour was unacceptable.

		This spawned a large-scale redesign regarding how the game lobby class dealt with the game state. Previously, the lobby, and therefore the main thread, would not only be responsible for running our tick updates to the state, but also for applying the sequence of updates required during lag compensation. However, the greater amount of time we have to compensate for equals a greater amount of time it takes to perform the compensation. This caused our Node event-loop to get severely, and frequently held-up.

		The problem was solved thanks to the development of our \texttt{StateController} class. Each game lobby instance would, within its constructor, instantiate a new instance of this \texttt{StateController} class. Within this \texttt{StateController} instance would live a separate process that was solely dedicated to applying individual updates to the game state. For a more in-depth description, see \fullref{sec:lobbyConcurrency}.

	\section{Technology Integration}
		Some of the most prevalent issues faced were those indirectly related to the project. Specifically the issues that came about due to the discretional use of third-party libraries, and other technologies.

		\subsection{Redux}
			Redux played a pretty superb job in handling our state. It kept our client's view layer in touch with the current game state (see \fullref{redux}). It even played a critical role in many of the tasks which occurred behind the scenes - those which weren't directly related to our game-state. Despite its successful integration into our application, it was the spawn of many challenges.

			For example, Redux is not natively equipped to deal with asynchronous events; such as communicating with the server, or detecting user keyboard input. Fortunately, there exist many additional libraries which tackle this problem. One of the asynchronous libraries is Redux Saga \parencite{reduxSaga}.

			Redux Sagae is a middleware that can be attached to Redux. It used into conjunction with the new JavaScript generators, to make dealing with asynchronous code in a React/Redux application easier and more natural to work with. The use of generators play as an alternative to callbacks, which can quickly grow to become out-of-hand. In principle, it builds upon the saga pattern \parencite{sagas}.

			For most jobs, Redux Saga is quite simple to use. However, integrating Redux Saga with Web-Sockets proved to be quite complicated - especially with regards to the use of JavaScript generators.

			Our implemented solution begins by first immediately requesting then establishing a Web-Socket connection with the server, and proceeds to maintain said connection. A saga is then set-up and tasked to constantly listen out for messages from the server, and upon receiving a message will spit out the appropriate Redux action containing the payload. A write saga is also set-up which listen for actions emitted to the store from the client. Once an action is received, it is appropriately packaged into a payload and shot off to the server using the maintained Web-Socket connection.

			This Web-Socket/Redux Saga adapter works very well, and is wrote in a generic manner, decoupled from the rest of the application, in order for it be feasibly integrated into other projects.
\end{document}